// Word Wrap - hard - 31/08/2023 
=================================

// Recursion + memoization
----------------------------
class Solution
{
    public int helper(int[] nums, int k, int i, Integer[] mem) {
        if(i == nums.length)
            return -1;
        if(mem[i] != null)
            return mem[i];
        int lineLen = 0;
        int ans = Integer.MAX_VALUE;
        for(int j = i;j<nums.length;j++) {
            lineLen += nums[j];
            int totalLen = lineLen+j-i;
            if(totalLen > k)
                break;
            int remaining = k-totalLen;
            int res = helper(nums, k, j+1, mem);
            if(res == -1)
                res = -remaining*remaining;
            ans = Math.min(ans, remaining*remaining+res);
        }
        return mem[i] = ans;
    }
    public int solveWordWrap (int[] nums, int k)
    {
        // Code here 
        return helper(nums, k, 0, new Integer[nums.length]);
    }
}


// Authors solution

class Solution
{
    public int solveWordWrap (int[] nums, int k)
    {
        // Code here 
        int n = nums.length;
        int i, j;

    // Variable to store 
    // number of characters 
    // in given line.
    int currlen;

    // Variable to store 
    // possible minimum 
    // cost of line.
    int cost;

    // DP table in which 
    // dp[i] represents 
    // cost of line starting
    // with word arr[i].
    int dp[] = new int[n];

    // Array in which ans[i]
    // store index of last 
    // word in line starting 
    // with word arr[i].
    int ans[] = new int[n];

    // If only one word is present 
    // then only one line is required. 
    // Cost of last line is zero. 
    // Hence cost of this line is zero. 
    // Ending point is also n-1 as 
    // single word is present.
    dp[n - 1] = 0;
    ans[n - 1] = n - 1;

    // Make each word first 
    // word of line by iterating 
    // over each index in arr.
    for (i = n - 2; i >= 0; i--) 
    {
        currlen = -1;
        dp[i] = Integer.MAX_VALUE;

        // Keep on adding words in 
        // current line by iterating 
        // from starting word upto 
        // last word in arr.
        for (j = i; j < n; j++) 
        {

            // Update number of characters
            // in current line. arr[j] is
            // number of characters in
            // current word and 1
            // represents space character
            // between two words.
            currlen += (nums[j] + 1);

            // If limit of characters
            // is violated then no more
            // words can be added to
            // current line.
            if (currlen > k)
                break;

            // If current word that is
            // added to line is last
            // word of arr then current
            // line is last line. Cost of
            // last line is 0. Else cost
            // is square of extra spaces
            // plus cost of putting line
            // breaks in rest of words
            // from j+1 to n-1.
            if (j == n - 1)
                cost = 0;
            else
                cost = (k - currlen) * 
                       (k - currlen) +
                            dp[j + 1];

            // Check if this arrangement
            // gives minimum cost for
            // line starting with word 
            // arr[i].
            if (cost < dp[i]) 
            {
                dp[i] = cost;
                ans[i] = j;
            }
        }
       }
       int res = 0;
        i = 0;
        while (i < n) {
            int pos = 0;
            for (j = i; j < ans[i] + 1; j++) {
                pos += nums[j];
            }
            int x = ans[i]-i;
            if(ans[i]+1 != n)
                res += (k - x - pos)*(k - x - pos);
            i = ans[i] + 1;
        }
        return res;
    }
}
